{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5b25d8b2-e630-4ae8-8002-3638d04d4929",
   "metadata": {},
   "outputs": [],
   "source": [
    "import csv\n",
    "import numpy as np\n",
    "from scipy.interpolate import interp1d\n",
    "\n",
    "\n",
    "def interpolate_bounding_boxes(data):\n",
    "    # Extract necessary data columns from input data\n",
    "    frame_numbers = np.array([int(row['frame_nmr']) for row in data])\n",
    "    car_ids = np.array([int(float(row['car_id'])) for row in data])\n",
    "    car_bboxes = np.array([list(map(float, row['car_bbox'][1:-1].split())) for row in data])\n",
    "    license_plate_bboxes = np.array([list(map(float, row['license_plate_bbox'][1:-1].split())) for row in data])\n",
    "\n",
    "    interpolated_data = []\n",
    "    unique_car_ids = np.unique(car_ids)\n",
    "    for car_id in unique_car_ids:\n",
    "\n",
    "        frame_numbers_ = [p['frame_nmr'] for p in data if int(float(p['car_id'])) == int(float(car_id))]\n",
    "        print(frame_numbers_, car_id)\n",
    "\n",
    "        # Filter data for a specific car ID\n",
    "        car_mask = car_ids == car_id\n",
    "        car_frame_numbers = frame_numbers[car_mask]\n",
    "        car_bboxes_interpolated = []\n",
    "        license_plate_bboxes_interpolated = []\n",
    "\n",
    "        first_frame_number = car_frame_numbers[0]\n",
    "        last_frame_number = car_frame_numbers[-1]\n",
    "\n",
    "        for i in range(len(car_bboxes[car_mask])):\n",
    "            frame_number = car_frame_numbers[i]\n",
    "            car_bbox = car_bboxes[car_mask][i]\n",
    "            license_plate_bbox = license_plate_bboxes[car_mask][i]\n",
    "\n",
    "            if i > 0:\n",
    "                prev_frame_number = car_frame_numbers[i-1]\n",
    "                prev_car_bbox = car_bboxes_interpolated[-1]\n",
    "                prev_license_plate_bbox = license_plate_bboxes_interpolated[-1]\n",
    "\n",
    "                if frame_number - prev_frame_number > 1:\n",
    "                    # Interpolate missing frames' bounding boxes\n",
    "                    frames_gap = frame_number - prev_frame_number\n",
    "                    x = np.array([prev_frame_number, frame_number])\n",
    "                    x_new = np.linspace(prev_frame_number, frame_number, num=frames_gap, endpoint=False)\n",
    "                    interp_func = interp1d(x, np.vstack((prev_car_bbox, car_bbox)), axis=0, kind='linear')\n",
    "                    interpolated_car_bboxes = interp_func(x_new)\n",
    "                    interp_func = interp1d(x, np.vstack((prev_license_plate_bbox, license_plate_bbox)), axis=0, kind='linear')\n",
    "                    interpolated_license_plate_bboxes = interp_func(x_new)\n",
    "\n",
    "                    car_bboxes_interpolated.extend(interpolated_car_bboxes[1:])\n",
    "                    license_plate_bboxes_interpolated.extend(interpolated_license_plate_bboxes[1:])\n",
    "\n",
    "            car_bboxes_interpolated.append(car_bbox)\n",
    "            license_plate_bboxes_interpolated.append(license_plate_bbox)\n",
    "\n",
    "        for i in range(len(car_bboxes_interpolated)):\n",
    "            frame_number = first_frame_number + i\n",
    "            row = {}\n",
    "            row['frame_nmr'] = str(frame_number)\n",
    "            row['car_id'] = str(car_id)\n",
    "            row['car_bbox'] = ' '.join(map(str, car_bboxes_interpolated[i]))\n",
    "            row['license_plate_bbox'] = ' '.join(map(str, license_plate_bboxes_interpolated[i]))\n",
    "\n",
    "            if str(frame_number) not in frame_numbers_:\n",
    "                # Imputed row, set the following fields to '0'\n",
    "                row['license_plate_bbox_score'] = '0'\n",
    "                row['license_number'] = '0'\n",
    "                row['license_number_score'] = '0'\n",
    "            else:\n",
    "                # Original row, retrieve values from the input data if available\n",
    "                original_row = [p for p in data if int(p['frame_nmr']) == frame_number and int(float(p['car_id'])) == int(float(car_id))][0]\n",
    "                row['license_plate_bbox_score'] = original_row['license_plate_bbox_score'] if 'license_plate_bbox_score' in original_row else '0'\n",
    "                row['license_number'] = original_row['license_number'] if 'license_number' in original_row else '0'\n",
    "                row['license_number_score'] = original_row['license_number_score'] if 'license_number_score' in original_row else '0'\n",
    "\n",
    "            interpolated_data.append(row)\n",
    "\n",
    "    return interpolated_data\n",
    "\n",
    "\n",
    "# Load the CSV file\n",
    "with open('test.csv', 'r') as file:\n",
    "    reader = csv.DictReader(file)\n",
    "    data = list(reader)\n",
    "\n",
    "# Interpolate missing data\n",
    "interpolated_data = interpolate_bounding_boxes(data)\n",
    "\n",
    "# Write updated data to a new CSV file\n",
    "header = ['frame_nmr', 'car_id', 'car_bbox', 'license_plate_bbox', 'license_plate_bbox_score', 'license_number', 'license_number_score']\n",
    "with open('test_interpolated.csv', 'w', newline='') as file:\n",
    "    writer = csv.DictWriter(file, fieldnames=header)\n",
    "    writer.writeheader()\n",
    "    writer.writerows(interpolated_data)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
